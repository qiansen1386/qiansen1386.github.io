<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发 on 东方孤思子のBlog
Paris·Qian Sen</title>
    <link>https://qiansen1386.github.io/categories/%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 开发 on 东方孤思子のBlog
Paris·Qian Sen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 03 Apr 2016 16:40:00 +0000</lastBuildDate>
    <atom:link href="https://qiansen1386.github.io/categories/%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Frontend Learning Notes 2 - Direction Shifted</title>
      <link>https://qiansen1386.github.io/p/2016-04-03/frontend-learning-note-2</link>
      <pubDate>Sun, 03 Apr 2016 16:40:00 +0000</pubDate>
      
      <guid>https://qiansen1386.github.io/p/2016-04-03/frontend-learning-note-2</guid>
      <description>

&lt;h2 id=&#34;my-confession&#34;&gt;My Confession&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Only the ignorant person fears nothing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I gotta say that I was way too over ambitious about the frontend stack. When companys like Google and Mozilla start to push the standardization of new innovations of the Web. The frontend standards keeps changing everyday, so does the Toolchain. Chasing the tool could be harmful, so I realised a realistic learning plan could be more benificial for me.
After a few days of extensive research, my mind changed. The more I learn, I become less bold, so that I become more and more eager for a shorter learning curve. Compareing with &amp;ldquo;Flawless on paper&amp;rdquo;, I prefer a more practical stack.
Here is what I learnt:&lt;/p&gt;

&lt;h3 id=&#34;postcss-scss&#34;&gt;&lt;code&gt;PostCSS&lt;/code&gt; =&amp;gt; &lt;code&gt;SCSS&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;I know the PostCSS is the future, and CssNext/preCss plugins appears like a great replacement of Scss. Also according to Boostrap &amp;amp; many others SCSS is way better than LESS. But then I find that if I want to custom and build Boostrap, I have to import SCSS anyway. So SCSS+Autoprefixer beat my original ideal buy ignorant plan.&lt;/p&gt;

&lt;h3 id=&#34;build-tool-module-bundler&#34;&gt;Build Tool &amp;amp; Module Bundler&lt;/h3&gt;

&lt;p&gt;There is a little bit backgound I have learnt.
- &lt;a href=&#34;http://gulpjs.com/&#34; target=&#34;_blank&#34;&gt;gulp&lt;/a&gt; beats &lt;a href=&#34;http://gruntjs.com/&#34; target=&#34;_blank&#34;&gt;grunt&lt;/a&gt;.
- &lt;a href=&#34;https://webpack.github.io&#34; target=&#34;_blank&#34;&gt;Webpack&lt;/a&gt; beats &lt;a href=&#34;http://gbrowserify.org&#34; target=&#34;_blank&#34;&gt;browserify&lt;/a&gt; beats &lt;a href=&#34;http://grequirejs.org&#34; target=&#34;_blank&#34;&gt;RequireJS&lt;/a&gt;.
- With the viral of &lt;code&gt;NodeJS&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt; becomes the de facto standard importing syntax(I believe). It Beats AMD, CMD and otheres, moreover &lt;code&gt;ES6 module&lt;/code&gt; is compatiable with it, so it is also future-proof.
- Webpack is capable to do some jobs of gulp.&lt;/p&gt;

&lt;p&gt;I was thinking of using gulp + webpack. But since nowadays, webpack have plenty of plugins and loaders, and most importantly, I found at least 2 boostrap-loaders which claims that they can process Boostrap v4. I can simply say good bye to Gulp. &lt;em&gt;I might meet you again, don&amp;rsquo;t know why, don&amp;rsquo;t know when, but I might meet you again some other day~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Webpack can minify Js, provide source map for dev stage, build SCSS, build typescript, build Vue/JSX, build Boostrap, include jQuery support without expose global access to it, process PostCSS(Autoprefixer), custom the dist path, watch the dev folder, live-reload. What else do you need? What else do you need? What else do you need?&lt;/p&gt;

&lt;h3 id=&#34;keep-practicing&#34;&gt;Keep Practicing&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;It is the only way to reveal the imperfection of your tool and to pursue perfection of understanding at the same time!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before practise, you won&amp;rsquo;t know if the tool is gonna suit your needs.
That is exactly why I dropped the semantic UI, because it follows &amp;ldquo;&lt;em&gt;Convention over Configuation&lt;/em&gt;&amp;rdquo;, so it has to sacrifice &amp;ldquo;&lt;em&gt;Explicit is better than implicit&lt;/em&gt;&amp;ldquo;&lt;small&gt;*Refering to &lt;a href=&#34;https://www.python.org/dev/peps/pep-0020/&#34; target=&#34;_blank&#34;&gt;The Zen of Python&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Before practise, you won&amp;rsquo;t know NodeJS have many dependency issue with Windows platform, so the &lt;code&gt;Vagrant&lt;/code&gt; become mandatory! no longer &lt;em&gt;Good to have&lt;/em&gt;. That is a good thing also, If I could compose my &lt;code&gt;Vagrantfile&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Nevertheless, this is absolutely worth our attention. However, it is neither stable nor mature. &lt;a href=&#34;https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/&#34; target=&#34;_blank&#34;&gt;https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;again-references&#34;&gt;Again, references&lt;/h2&gt;

&lt;h3 id=&#34;nodejs&#34;&gt;NodeJS:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/pU9Q6oiQNd0&#34; target=&#34;_blank&#34;&gt;What is Node.js Exactly? - a beginners introduction to Nodejs(YouTube)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/HkFlM73G-hk?list=PLoYCgNOIyGABs-wDaaxChu82q_xQgUb4f&#34; target=&#34;_blank&#34;&gt;Modular Javascript - Javascript Tutorial on the Object Literal Pattern(YouTube)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;webpack&#34;&gt;WebPack:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/TaWKUpahFZM&#34; target=&#34;_blank&#34;&gt;Getting Started with webpack(YouTube)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/9kJVYpOqcVU&#34; target=&#34;_blank&#34;&gt;Webpack Tutorial - Replace Gulp/Grunt plugins with a single tool(YouTube)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/vajoy/p/4650467.html&#34; target=&#34;_blank&#34;&gt;一小时包教会 —— webpack 入门指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zhuanlan.zhihu.com/p/20367175&#34; target=&#34;_blank&#34;&gt;Webpack傻瓜式指南（一）- 张轩(知乎)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zhuanlan.zhihu.com/p/20367175&#34; target=&#34;_blank&#34;&gt;Webpack傻瓜指南（二）开发和部署技巧- 张轩(知乎)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vue&#34;&gt;Vue:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://vuejs.org/guide/&#34; target=&#34;_blank&#34;&gt;Getting Started - vue.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://vuejs.org.cn/guide/&#34; target=&#34;_blank&#34;&gt;VueJs 官方指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://vuex.vuejs.org/zh-cn/quickstart.html&#34; target=&#34;_blank&#34;&gt;Vuex 官方指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://router.vuejs.org/zh-cn/basic.html&#34; target=&#34;_blank&#34;&gt;Vue-router 官方指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sally-xiao.gitbooks.io/book/content/index.html&#34; target=&#34;_blank&#34;&gt;如何用Vue.js来搭建一个简易的APP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vagrant&#34;&gt;Vagrant:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/Dji9ALCgfpM&#34; target=&#34;_blank&#34;&gt;Ruby Programming in One Video(Youtube)&lt;/a&gt;: In one video series is great for syntax-learning.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vagrantup.com/docs/&#34; target=&#34;_blank&#34;&gt;VAGRANT DOCUMENTATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/drmyersii/vagrant-node-env&#34; target=&#34;_blank&#34;&gt;vagrant-node-env(Github)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laravel/homestead&#34; target=&#34;_blank&#34;&gt;laravel/homestead(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;page-load-effect&#34;&gt;Page Load Effect:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://javascript.nwbox.com/ContentLoaded/&#34; target=&#34;_blank&#34;&gt;ContentLoaded(2010)&lt;/a&gt; A page load library,used by webpack.github.io&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codyhouse.co/gem/animated-page-transition/&#34; target=&#34;_blank&#34;&gt;Animated page trasition&lt;/a&gt; Worth investigation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/browserstate/history.js&#34; target=&#34;_blank&#34;&gt;History.js&lt;/a&gt; Need no introduction&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fasw.ws/faswwp/non-jquery-page-transitions-lightweight/&#34; target=&#34;_blank&#34;&gt;Non-Jquery Page Transitions lightweight&lt;/a&gt; A great proof of concept&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://turbo-react.herokuapp.com/&#34; target=&#34;_blank&#34;&gt;TurboReact&lt;/a&gt; A react based implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/turbolinks/turbolinks&#34; target=&#34;_blank&#34;&gt;Turbolinks&lt;/a&gt; extraction of above solution, the best library to use by far&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[转] ES6 的模块系统（附CommonJS &amp; AMD 相关）</title>
      <link>https://qiansen1386.github.io/p/2016-03-28/es6-module-system</link>
      <pubDate>Mon, 28 Mar 2016 10:14:24 +0000</pubDate>
      
      <guid>https://qiansen1386.github.io/p/2016-03-28/es6-module-system</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000003410285&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt; by &lt;a href=&#34;https://segmentfault.com/blog/juryxiong&#34; target=&#34;_blank&#34;&gt;Jury Xiong&amp;rsquo;s Blog&lt;/a&gt; 依照&lt;a href=&#34;http://creativecommons.org/licenses/by-sa/3.0/cn/&#34; target=&#34;_blank&#34;&gt;知识共享署名-相同方式共享 3.0 中国大陆许可协议&lt;/a&gt;发布&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此文为翻译，原文地址在这儿：&lt;a href=&#34;https://hacks.mozilla.org/2015/08/es6-in-depth-modules/&#34; target=&#34;_blank&#34;&gt;https://hacks.mozilla.org/2015/08/es6-in-depth-modules/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ES6 是 ECMAScript 第 6 版本的简称，这是新一代的 JavaScript 的标准。&lt;a href=&#34;https://hacks.mozilla.org/category/es6-in-depth/&#34; target=&#34;_blank&#34;&gt;ES6 in Depth&lt;/a&gt; 是关于 ES6 的一系列新特性的介绍。&lt;/p&gt;

&lt;p&gt;遥想 2007 年，笔者开始在 Mozilla 的 JavaScript 团队工作的时候，那个时候典型的 JavaScript 程序只有一行代码。&lt;/p&gt;

&lt;p&gt;两年之后， Google Map 被发布。但是在那之前不久，JavaScript 的主要用途还是表单验证，当然啦，你的&lt;code&gt;&amp;lt;input onchange=&amp;gt;&lt;/code&gt;处理器平均来说只有一行。&lt;/p&gt;

&lt;p&gt;事过情迁，JavaScript 项目已经变得十分庞大，社区也发展出了一些有助于开发可扩展程序的工具。首先你需要的便是模块系统。模块系统让你得以将你的工作分散在不同的文件和目录中，让它们之前得以互相访问，并且可以非常有效地加载它们。自然而然地，JavaScript 发展出了模块系统，事实上是多个模块系统（AMD，CommonJS，CMD，译者注）。不仅如此，社区还提供了包管理工具（NPM，译者注），让你可以安装和拷贝高度依赖其他模块的软件。也许你会觉得，带有模块特性的 ES6，来得有些晚了。&lt;/p&gt;

&lt;h2 id=&#34;模块基础&#34;&gt;模块基础&lt;/h2&gt;

&lt;p&gt;一个 ES6 的模块是一个包含了 JS 代码的文件。ES6 里没有所谓的 &lt;code&gt;module&lt;/code&gt; 关键字。一个模块看起来就和一个普通的脚本文件一样，除了以下两个区别：&lt;/p&gt;

&lt;p&gt;ES6 的模块自动开启严格模式，即使你没有写 &lt;code&gt;&#39;use strict&#39;&lt;/code&gt;。
你可以在模块中使用 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt;。
让我们先来看看 &lt;code&gt;export&lt;/code&gt;。在模块中声明的任何东西都是默认私有的，如果你想对其他模块 Public，你必须 &lt;code&gt;export&lt;/code&gt; 那部分代码。我们有几种实现方法，最简单的方式是添加一个 &lt;code&gt;export&lt;/code&gt; 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;// kittydar.js - Find the locations of all the cats in an image.
// (Heather Arthur wrote this library for real)
// (but she didn&#39;t use modules, because it was 2013)

export function detectCats(canvas, options) {
  var kittydar = new Kittydar(options);
  return kittydar.detectCats(canvas);
}

export class Kittydar {
  ... several methods doing image processing ...
}

// This helper function isn&#39;t exported.
function resizeCanvas() {
  ...
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在 &lt;code&gt;function&lt;/code&gt;、&lt;code&gt;class&lt;/code&gt;、&lt;code&gt;var&lt;/code&gt;、&lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 前添加 &lt;code&gt;export&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果你想写一个模块，有这些就够了！再也不用把代码放在 IIFE 或者一个回调函数里了。既然你的代码是一个模块，而非脚本文件，那么你生命的一切都会被封装进模块的作用域，不再会有跨模块或跨文件的全局变量。你导出的声明部分则会成为这个模块的 Public API。&lt;/p&gt;

&lt;p&gt;除此之外，模块里的代码和普通代码没啥大区别。它可以访问一些基本的全局变量，比如 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt;。如果你的模块跑在浏览器里，它将可以访问 &lt;code&gt;document&lt;/code&gt; 和 &lt;code&gt;XMLHttpRequest&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在另外一个文件中，我们可以导入这个模块并且使用 &lt;code&gt;detectCats()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;// demo.js - Kittydar demo program

import {detectCats} from &amp;quot;kittydar.js&amp;quot;;

function go() {
    var canvas = document.getElementById(&amp;quot;catpix&amp;quot;);
    var cats = detectCats(canvas);
    drawRectangles(canvas, cats);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要导入多个模块中的接口，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;import {detectCats, Kittydar} from &amp;quot;kittydar.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你运行一个包含 &lt;code&gt;import&lt;/code&gt; 声明的模块，被引入的模块会先被导入并加载，然后根据依赖关系，每一个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，以此避免依赖循环。&lt;/p&gt;

&lt;p&gt;这便是模块的基础部分，挺简单的。&lt;/p&gt;

&lt;h2 id=&#34;导出表&#34;&gt;导出表&lt;/h2&gt;

&lt;p&gt;如果你觉得在每个要导出的部分前都写上 export 很麻烦，你可以只写一行你想要导出的变量列表，再用花括号包起来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;export {detectCats, Kittydar};

// no `export` keyword required here
function detectCats(canvas, options) { ... }
class Kittydar { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出表不一定要出现在文件的第一行，它可以出现在模块顶级作用域中的任何一行。你可以写多个导出表，也可以在列表中再写上其他 &lt;code&gt;export&lt;/code&gt; 声明，只要没有变量名被重复导出即可。&lt;/p&gt;

&lt;h2 id=&#34;重名命导出和导入&#34;&gt;重名命导出和导入&lt;/h2&gt;

&lt;p&gt;如果导入的变量名恰好和你模块中的变量名冲突了，ES6 允许你给你导入的东西重命名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;// suburbia.js

// Both these modules export something named `flip`.
// To import them both, we must rename at least one.
import {flip as flipOmelet} from &amp;quot;eggs.js&amp;quot;;
import {flip as flipHouse} from &amp;quot;real-estate.js&amp;quot;;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似地，你在导出变量的时候也能重命名。这个特性在你想将同一个变量名导出两次的场景下十分方便，举个栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;// unlicensed_nuclear_accelerator.js - media streaming without drm
// (not a real library, but maybe it should be)

function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;默认导出&#34;&gt;默认导出&lt;/h2&gt;

&lt;p&gt;新一代的标准的设计理念是兼容现有的 &lt;code&gt;CommonJS&lt;/code&gt; 和 &lt;code&gt;AMD&lt;/code&gt; 模块。所以如果你有一个 Node 项目，并且刚刚执行完 &lt;code&gt;npm install lodash&lt;/code&gt;，你的 ES6 代码可以独立引入 Lodash 中的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;import {each, map} from &amp;quot;lodash&amp;quot;;

each([3, 2, 1], x =&amp;gt; console.log(x));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而如果你已经习惯了 &lt;code&gt;_.each&lt;/code&gt; 或者看不见 &lt;code&gt;_&lt;/code&gt; 的话就浑身难受，当然这样使用 Lodash 也是不错的方式。&lt;/p&gt;

&lt;p&gt;这种情况下，你可以稍微改变一下你的 import 写法，不写花括号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;import _ from &amp;quot;lodash&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个简写等价于 &lt;code&gt;import {default as _} from &amp;quot;lodash&amp;quot;;&lt;/code&gt;。所有 &lt;code&gt;CommonJS&lt;/code&gt; 和 &lt;code&gt;AMD&lt;/code&gt; 模块在被 ES6 代码使用的时候都已经有了默认的导出，这个导出和你在 &lt;code&gt;CommonJS&lt;/code&gt; 中 &lt;code&gt;require()&lt;/code&gt; 得到的东西是一样的，那就是 &lt;code&gt;exports&lt;/code&gt; 对象。&lt;/p&gt;

&lt;p&gt;ES6 的模块系统被设计成让你可以一次性引入多个变量。但对于已经存在的 CommonJS 模块来说，你能得到的只有默认导出。举个栗子，在撰写此文之时，据笔者所知，著名的 &lt;a href=&#34;https://github.com/Marak/colors.js&#34; target=&#34;_blank&#34;&gt;colors&lt;/a&gt; 模块并未特意支持 ES6。这是一个由多个 CommonJS 模块组成的模块，正如 npm 上的那些包。然而你依然可以直接将其引入到你的 ES6 代码中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;// ES6 equivalent of `var colors = require(&amp;quot;colors/safe&amp;quot;);`
import colors from &amp;quot;colors/safe&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想写自己的默认导出，那也很简单。这里面并没有什么高科技，它和普通的导出没什么两样，除了它的导出名是 &lt;code&gt;default&lt;/code&gt;。你可以使用我们之前已经介绍过的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;let myObject = {
  field1: value1,
  field2: value2
};
export {myObject as default};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样更好：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;export default {
  field1: value1,
  field2: value2
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export default&lt;/code&gt; 关键字后可以跟随任何值：函数，对象，对象字面量，任何你能说得出的东西。&lt;/p&gt;

&lt;h2 id=&#34;模块对象&#34;&gt;模块对象&lt;/h2&gt;

&lt;p&gt;抱歉，这篇文章的内容有点多，但 JavaScript 已经算好的了：因为一些原因，所有语言的模块系统都有一大堆没什么卵用的特性。所幸的是，咱们只有一个话题要讨论了，呃，好吧，两个。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;import * as cows from &amp;quot;cows&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你 &lt;code&gt;import *&lt;/code&gt;，被引入进来的是一个 &lt;code&gt;module namespace object&lt;/code&gt;。它的属性是那个模块的导出，所以如果 “cows” 模块导出了一个名为 &lt;code&gt;moo()&lt;/code&gt; 的函数，当你像这样引入了 “cows” 之后，你可以这样写 &lt;code&gt;cows.moo()&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;聚合模块&#34;&gt;聚合模块&lt;/h2&gt;

&lt;p&gt;有时候一个包的主模块会引入许多其他模块，然后再将它们以一个统一的方式导出。为了简化这样的代码，我们有一个 import-and-export 的简写方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Node&#34;&gt;// world-foods.js - good stuff from all over

// import &amp;quot;sri-lanka&amp;quot; and re-export some of its exports
export {Tea, Cinnamon} from &amp;quot;sri-lanka&amp;quot;;

// import &amp;quot;equatorial-guinea&amp;quot; and re-export some of its exports
export {Coffee, Cocoa} from &amp;quot;equatorial-guinea&amp;quot;;

// import &amp;quot;singapore&amp;quot; and export ALL of its exports
export * from &amp;quot;singapore&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种 &lt;code&gt;export-from&lt;/code&gt; 的表达式和后面跟了一个 &lt;code&gt;export&lt;/code&gt; 的 &lt;code&gt;import-from&lt;/code&gt; 表达式类似。但和真正的导入不同，它并不会在你的作用域中加入二次导出的变量绑定。所以如果你打算在 &lt;code&gt;world-foods.js&lt;/code&gt; 写用到了 &lt;code&gt;Tea&lt;/code&gt; 的代码，就别使用这个简写形式。&lt;/p&gt;

&lt;p&gt;如果 &amp;ldquo;singapore&amp;rdquo; 导出的某一个变量恰巧和其他的导出变量名冲突了，那么这里就会出现一个错误。所以你应该谨慎使用 &lt;code&gt;export *&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Whew！我们介绍完语法了，接下来进入有趣的环节。&lt;/p&gt;

&lt;h2 id=&#34;import-到底干了啥&#34;&gt;&lt;code&gt;import&lt;/code&gt; 到底干了啥&lt;/h2&gt;

&lt;p&gt;啥也没干，信不信由你。&lt;/p&gt;

&lt;p&gt;噢，你好像看起来没那么好骗。好吧，那你相信标准几乎没有谈到 &lt;code&gt;import&lt;/code&gt; 该做什么吗？你认为这是一件好事还是坏事呢？&lt;/p&gt;

&lt;p&gt;ES6 将模块的加载细节&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule&#34; target=&#34;_blank&#34;&gt;完全交给了实现&lt;/a&gt;，其余的执行部分则&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob&#34; target=&#34;_blank&#34;&gt;规定得非常详细&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;大致来说，当 JS 引擎运行一个模块的时候，它的行为大致可归纳为以下四步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;解析：引擎实现会阅读模块的源码，并且检查是否有语法错误。&lt;/li&gt;
&lt;li&gt;加载：引擎实现会（递归地）加载所有被引入的模块。这部分咱还没标准化。&lt;/li&gt;
&lt;li&gt;链接：引擎实现会为每个新加载的模块创建一个作用域，并且将模块中的声明绑定填入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，包括从其他模块中引入的。
当你尝试 &lt;code&gt;import {cake} from &amp;quot;paleo&amp;quot;&lt;/code&gt; 但是 “paleo” 模块并没有导出叫 &lt;code&gt;cake&lt;/code&gt; 的东西时候，你也会在此时得到错误。这很糟糕，因为你离执行 JS，品尝 &lt;code&gt;cake&lt;/code&gt; 只差一步了！&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行：终于，JS 引擎开始执行刚加载进来的模块中的代码。到这个时候，&lt;code&gt;import&lt;/code&gt; 的处理过程已经完成，因此当 JS 引擎执行到一行 import 声明的时候，它啥也不会干。
看到了不？我说了 &lt;code&gt;import&lt;/code&gt; “啥也没干”，没骗你吧？有关编程语言的严肃话题，哥从不说谎。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过，现在咱们可以介绍这个体系中有趣的部分了，这是一个非常酷的 trick。正因为这个体系并没有指定加载的细节，也因为你只需要看一眼源码中的 &lt;code&gt;import&lt;/code&gt; 声明就可以在运行前搞清楚模块的依赖，某些 ES6 的实现甚至可以通过预处理就完成所有的工作，然后将模块全部打包成一个文件，最后通过网络分发。像 &lt;a href=&#34;http://www.2ality.com/2015/04/webpack-es6.html&#34; target=&#34;_blank&#34;&gt;webpack&lt;/a&gt; 这样的工具就是做这个事情的。&lt;/p&gt;

&lt;p&gt;这非常的了不起，因为通过网络加载资源是非常耗时的。假设你请求一个资源，接着发现里面有 &lt;code&gt;import&lt;/code&gt; 声明，然后你又得请求更多的资源，这又会耗费更多的时间。一个 naive 的 loader 实现可能会发起许多次网络请求。但有了 webpack，你不仅可以在今天就开始使用 ES6，还可以得到一切模块化的好处并且不向运行时性能妥协。&lt;/p&gt;

&lt;p&gt;原先我们计划过一个详细定义的 ES6 模块加载规范，而且我们做出来了。它没有成为最终标准的原因之一是它无法与打包这一特性调和。模块系统需要被标准化，打包也不应该被放弃，因为它太好了。&lt;/p&gt;

&lt;h2 id=&#34;动态-vs-静态-或者说-规矩和如何打破规矩&#34;&gt;动态 VS 静态，或者说：规矩和如何打破规矩&lt;/h2&gt;

&lt;p&gt;作为一门动态编程语言，JavaScript 令人惊讶地拥有一个静态的模块系统。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 只能写在顶级作用域中。你无法在条件语句中使用引入和导出，你也不能在你写的函数作用域中使用 &lt;code&gt;import&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;所有的导出必须显示地指定一个变量名，你也无法通过一个循环动态地引入一堆变量。&lt;/li&gt;
&lt;li&gt;模块对象被封装起来了，我们无法通过 polyfill 去 hack 一个新 feature。&lt;/li&gt;
&lt;li&gt;在模块代码运行之前，所有的模块都必须经历加载，解析，链接的过程。没有可以延迟加载，惰性 &lt;code&gt;import&lt;/code&gt; 的语法。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;import&lt;/code&gt; 错误，你无法在运行时进行 &lt;code&gt;recovery&lt;/code&gt;。一个应用可能包含了几百个模块，其中的任何一个加载失败或链接失败，这个应用就不会运行。你无法在 &lt;code&gt;try/catch&lt;/code&gt; 语句中 &lt;code&gt;import&lt;/code&gt;。（不过正因为 ES6 的模块系统是如此地静态，webpack 可以在预处理时就为你检测出这些错误）。&lt;/li&gt;
&lt;li&gt;你没办法 hook 一个模块，然后在它被加载之前运行你的一些代码。这意味着模块无法控制它的依赖是如何被加载的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只要你的需求都是静态的话，这个模块系统还是很 nice 的。但你还是想 hack 一下，是吗？&lt;/p&gt;

&lt;p&gt;这就是为啥你使用的模块加载系统可能会提供 API。举个栗子，&lt;a href=&#34;http://webpack.github.io/docs/code-splitting.html&#34; target=&#34;_blank&#34;&gt;webpack 有一个 API&lt;/a&gt;，允许你 “code splitting”，按照你的需求去惰性加载模块。这个 API 也能帮你打破上面列出的所有规矩。&lt;/p&gt;

&lt;p&gt;ES6 的模块是非常静态的，这很好——许多强大的编译器工具因此收益。而且，静态的语法已经被设计成可以和动态的，可编程的 loader API 协同工作。&lt;/p&gt;

&lt;h2 id=&#34;我何时能开始使用-es6-模块&#34;&gt;我何时能开始使用 ES6 模块？&lt;/h2&gt;

&lt;p&gt;如果你今天就要开始使用，你需要诸如 &lt;a href=&#34;https://github.com/google/traceur-compiler#what-is-traceur&#34; target=&#34;_blank&#34;&gt;Traceur&lt;/a&gt; 和 &lt;a href=&#34;http://babeljs.io/&#34; target=&#34;_blank&#34;&gt;Babel&lt;/a&gt; 这样的预处理工具。这个系列专题之前也有文章介绍了&lt;a href=&#34;https://hacks.mozilla.org/2015/06/es6-in-depth-babel-and-broccoli/&#34; target=&#34;_blank&#34;&gt;如何使用 Babel 和 Broccoli&lt;/a&gt; 去生成可用于 Web 的 ES6 代码。那篇文章的栗子也被&lt;a href=&#34;https://github.com/givanse/broccoli-babel-examples/tree/master/es6-modules&#34; target=&#34;_blank&#34;&gt;开源在了 GitHub 上&lt;/a&gt;。笔者的&lt;a href=&#34;http://www.2ality.com/2015/04/webpack-es6.html&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;也介绍了如何使用 Babel 和 webpack。&lt;/p&gt;

&lt;p&gt;ES6 模块系统的主要设计者是 Dave Herman 和 Sam Tobin-Hochstadt，此二人不顾包括笔者在内的数位委员的反对，始终坚持如今你见到的 ES6 模块系统的静态部分，争论长达数年。Jon Coppeard 正在火狐浏览器上实现 ES6 的模块。之后包括 JavaScript Loader 规范在内的工作已经在进行中。HTML 中类似 &lt;code&gt;&amp;lt;script type=module&amp;gt;&lt;/code&gt; 这样的东西之后也会和大家见面。&lt;/p&gt;

&lt;p&gt;这便是 ES6 了。&lt;/p&gt;

&lt;p&gt;欢迎大家对 ES6 进行吐槽，请期待下周 &lt;a href=&#34;https://hacks.mozilla.org/category/es6-in-depth/&#34; target=&#34;_blank&#34;&gt;ES6 in Depth&lt;/a&gt; 系列的总结文章。
&lt;small style=&#34;float:right&#34;&gt;2015年08月21日发布&lt;/small&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;除此文之外，还推荐其他参考资料，因版权不明，我尽量多导流少转载：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://javascript.ruanyifeng.com/nodejs/module.html&#34; target=&#34;_blank&#34;&gt;CommonJS规范 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cnodejs.org/topic/5231a630101e574521e45ef8&#34; target=&#34;_blank&#34;&gt;exports 和 module.exports 的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html&#34; target=&#34;_blank&#34;&gt;浏览器加载 CommonJS 模块的原理与实现 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&#34; target=&#34;_blank&#34;&gt;Javascript模块化编程（一）：模块的写法 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&#34; target=&#34;_blank&#34;&gt;Javascript模块化编程（二）：AMD规范 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/11/require_js.html&#34; target=&#34;_blank&#34;&gt;Javascript模块化编程（三）：require.js的用法 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;AMD&amp;rdquo;文档（中文版）存档&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Frontend Learning Notes - Starting Point</title>
      <link>https://qiansen1386.github.io/p/2016-03-16/frontend-learning-note</link>
      <pubDate>Wed, 16 Mar 2016 07:03:51 +0000</pubDate>
      
      <guid>https://qiansen1386.github.io/p/2016-03-16/frontend-learning-note</guid>
      <description>

&lt;p&gt;Recently, I have migrated to Hugo Site generator as you can see. I was pretty disappointed with most of the theme.
Even those great themes seem to have flaws, or require customization. And then I thought, if none of the theme is perfect
for me, why not craft one by my own. Since I always been fascinated by the frontend development, I take it as a
oppertunaty to bring my frontend skill sets to another level.&lt;/p&gt;

&lt;p&gt;So I created the stupid &lt;a href=&#34;github.com/qiansen1386/hugo-polygon-theme&#34; target=&#34;_blank&#34;&gt;hugo-polygon-theme&lt;/a&gt;. I have got to say, the name is pretty arbitrary.
Even worse, I don&amp;rsquo;t have a clue even after I started. I start to realised that I need to have more input before I make an output.
Hence, I started my long-term(supposed to be) voyage. Here are the resources that absolutely worth more attention.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Some of the resources are written in Chinese. Sorry for the inconvenience, coz those materials are slightly easier for me to understand.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;html5&#34;&gt;HTML5:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://html5boilerplate.com/&#34; target=&#34;_blank&#34;&gt;H5 boilerplate&lt;/a&gt; (Html5 boilerplate)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/h5bp/html5-boilerplate/blob/5.3.0/dist/doc/usage.md&#34; target=&#34;_blank&#34;&gt;H5 boilerplate Docs&lt;/a&gt; (Html5 boilerplate)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.initializr.com/builder?print&amp;amp;h5bp-content&amp;amp;modernizr&amp;amp;h5bp-chromeframe&amp;amp;h5bp-analytics&amp;amp;h5bp-favicon&amp;amp;h5bp-robots&amp;amp;h5bp-humans&amp;amp;h5bp-404&amp;amp;h5bp-adobecrossdomain&amp;amp;h5bp-css&amp;amp;h5bp-csshelpers&amp;amp;h5bp-mediaqueryprint&amp;amp;h5bp-mediaqueries&amp;amp;simplehtmltag&amp;amp;izr-emptyscript&#34; title=&#34;H5 boilerplate my custom build (a minimized version)&#34; target=&#34;_blank&#34;&gt;H5 boilerplate my custom build (a minimized version)&lt;/a&gt; (Html5 boilerplate)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://semantic-ui.com/&#34; target=&#34;_blank&#34;&gt;Semantic UI&lt;/a&gt; (LESS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://davidtheclark.com/excited-about-postcss/&#34; target=&#34;_blank&#34;&gt;Excited about postcss &amp;ndash; DAVID CLARK&lt;/a&gt; (PostCSS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://benfrain.com/breaking-up-with-sass-postcss/&#34; target=&#34;_blank&#34;&gt;Breaking up with Sass: it’s not you, it’s me &amp;ndash; Ben Frain&lt;/a&gt; (PostCSS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://twin.github.io/css-preprocessing-drama/&#34; target=&#34;_blank&#34;&gt;CSS Preprocessing Drama&lt;/a&gt; (PostCSS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ai/about-postcss/blob/master/speech.md&#34; target=&#34;_blank&#34;&gt;Speech of &amp;ldquo;About-postcss&amp;rdquo; &amp;ndash; AI&lt;/a&gt; (PostCSS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ashleynolan.co.uk/blog/postcss-a-review&#34; target=&#34;_blank&#34;&gt;PostCSS – Sass Killer or Preprocessing Pretender?&lt;/a&gt; (PostCSS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://learnlayout.com/&#34; target=&#34;_blank&#34;&gt;Learn CSS Layout(I18N-provided)&lt;/a&gt; (CSS fundamentals)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itmyhome.gitbooks.io/css/content/&#34; target=&#34;_blank&#34;&gt;CSS 编码规范&lt;/a&gt; (CSS fundamentals)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arguseye.gitbooks.io/postcss/content/plugins.html&#34; target=&#34;_blank&#34;&gt;PostCSS的相关知识&lt;/a&gt; (PostCSS)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;js&#34;&gt;JS:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://davidbcalhoun.com/2014/what-is-amd-commonjs-and-umd/&#34; target=&#34;_blank&#34;&gt;What Is AMD, CommonJS, and UMD?&lt;/a&gt; (Loading)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/TypeScript&#34; target=&#34;_blank&#34;&gt;TypeScript &amp;ndash;维基百科&lt;/a&gt; (TypeScript)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/smartkid/archive/2012/10/05/A_First_Look_Of_TypeScript.html&#34; target=&#34;_blank&#34;&gt;Typescript 初体验&lt;/a&gt; (TypeScript)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhongsp.gitbooks.io/typescript-handbook/content/&#34; target=&#34;_blank&#34;&gt;TypeScript Handbook（中文版）&lt;/a&gt; (TypeScript)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.75team.com/archives/882&#34; target=&#34;_blank&#34;&gt;[译]神马是AMD, CommonJS, UMD?&lt;/a&gt; (Translation of &amp;ldquo;What Is AMD, CommonJS, and UMD?&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Recursion-Demo in TypeScript &amp; How it get better</title>
      <link>https://qiansen1386.github.io/p/2016-03-07/recursion-demo-in-typescript</link>
      <pubDate>Mon, 07 Mar 2016 10:41:06 +0000</pubDate>
      
      <guid>https://qiansen1386.github.io/p/2016-03-07/recursion-demo-in-typescript</guid>
      <description>&lt;p&gt;I wrote this to practice of TypeScript and also to demonstrate recursion to my friend. This is a little challenge sent to me by one of my friend who is self-learning python, and recursion at the same time. Basically is about to keep removing all the elements whichever index is odd from the array, till there is only one left, and return the index of the survivor. Input the &lt;strong&gt;N&lt;/strong&gt; of elements and output the index &lt;strong&gt;X&lt;/strong&gt;.&lt;/p&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;500&#34; src=&#34;//jsfiddle.net/qiansen1386/yLdr5082/embedded/js,html,result/&#34; allowfullscreen=&#34;allowfullscreen&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Before I wrote this, I already know it is the dummiest(also most reliable) solution. Basically, it waste both Ram and execution time. There is no human-intelligence involved so far, just pure brute-force method which straight away simulate the whole process and return its predicting result. Just it is not really a prediction, but just a simulation&amp;hellip; After I observe the result, I laughed. What a dumb question, and I can&amp;rsquo;t believe how silly I am, LOL.&lt;/p&gt;

&lt;p&gt;Let put the result away first, and take a little bit time to look at the big O. Accoding to my code, The O is in the range &lt;code&gt;log2(n-1)&amp;lt;O&amp;lt;=log2(n)&lt;/code&gt;. Classic! Now, if you notice, the result is always the greatest &lt;code&gt;2^n&lt;/code&gt; which does not exceed the &lt;strong&gt;n&lt;/strong&gt;. we can change the algorithm to a simplier formula:&lt;/p&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;500&#34; src=&#34;//jsfiddle.net/qiansen1386/zvLu7re5/embedded/js,html,result/&#34; allowfullscreen=&#34;allowfullscreen&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;What is the O? Actually it&amp;rsquo;s still almost the same, the performance and amount of code have improved though.
What is the ultmate solution, use one calculation, the ultmate O(1) solution:&lt;/p&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;500&#34; src=&#34;//jsfiddle.net/qiansen1386/cvasL16t/embedded/js,html,result/&#34; allowfullscreen=&#34;allowfullscreen&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt; 

&lt;p&gt;That&amp;rsquo;s it! How silly I am&amp;hellip; But I am so happy about it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>终于成功了</title>
      <link>https://qiansen1386.github.io/p/2016-02-01/first-ever-post</link>
      <pubDate>Mon, 01 Feb 2016 06:53:50 +0000</pubDate>
      
      <guid>https://qiansen1386.github.io/p/2016-02-01/first-ever-post</guid>
      <description>&lt;p&gt;成功啦，哈哈哈。
现在只要&lt;code&gt;push&lt;/code&gt;到&lt;code&gt;source&lt;/code&gt;分支就能实时构建并推送到&lt;code&gt;master&lt;/code&gt;。大家可以看我的 &lt;a href=&#34;https://github.com/qiansen1386/qiansen1386.github.io&#34; target=&#34;_blank&#34;&gt;github repo&lt;/a&gt;
具体设置请参考下面的参考链接，Wercker 并不会很难，还是挺好理解的。
Wercker 也真的很好用，运用 docker 技术的自动化产品不要太方便，真的可以不用 jenkins 了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;主要参考了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fatestigma.github.io/2016/01/29/%E4%BD%BF%E7%94%A8-wercker-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/&#34; target=&#34;_blank&#34;&gt;使用 Wercker 自动化部署静态博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/tutorials/automated-deployments/&#34; target=&#34;_blank&#34;&gt;【官方】Automated deployments with Wercker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34; target=&#34;_blank&#34;&gt;【coderzh CoderZh Blog】使用hugo搭建个人博客站点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kaichu.io/2015/07/my-first-post/&#34; target=&#34;_blank&#34;&gt;【kaichu.io】在 Github Pages 建立 Hugo 靜態網站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>