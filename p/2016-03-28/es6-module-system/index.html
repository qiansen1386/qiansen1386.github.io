<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>[转] ES6 的模块系统（附CommonJS &amp; AMD 相关）</title>
  
  <link rel="stylesheet" href="https://qiansen1386.github.io/css/poole.css">
  <link rel="stylesheet" href="https://qiansen1386.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://qiansen1386.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://qiansen1386.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://qiansen1386.github.io/css/site.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/railscasts.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://www.gravatar.com/avatar/c6f58a99408d7e443ce3c791eb0647ad?s=144">
  <link rel="shortcut icon" href="https://www.gravatar.com/avatar/c6f58a99408d7e443ce3c791eb0647ad?s=16" />
  

  
  
  
  <meta name="description" content="本文木有简述">
  <meta name="keywords" content="NodeJs,ES6,前端,frontend,模块">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47725881-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/c6f58a99408d7e443ce3c791eb0647ad?s=150"
             alt="gravatar" title="东方孤思子&lt;br&gt;Paris Qian Sen">
      
      <h2>东方孤思子<br>Paris Qian Sen</h2>
      <p class="lead">Profesional Coding<br>Simple Living<br>Creative Thinking</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://qiansen1386.github.io/">Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="https://qiansen1386.github.io/about/">Who am I</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/qiansen1386"><i class="fa fa-github-square fa-2x"></i></a>
      
      <a href="http://stackexchange.com/users/1586938/paris-qian"><i class="fa fa-stack-overflow fa-2x"></i></a>
      <a href="https://sg.linkedin.com/in/parisqiansen"><i class="fa fa-linkedin-square fa-2x"></i></a>
      <a href="https://plus.google.com/&#43;Parisqiansen/posts"><i class="fa fa-google-plus-square fa-2x"></i></a>
      
      <a href="https://twitter.com/qiansen1386"><i class="fa fa-twitter-square fa-2x"></i></a>
      <a href="https://www.youtube.com/channel/UC1rGIQJUQABgRyA-edmRlKg"><i class="fa fa-youtube-square fa-2x"></i></a>
      <a href="https://qiansen1386.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-2x"></i></a>
      </li>
    </ul>

    
    <p><script id='flattr'>
      (function(id){
        var s = document.getElementById(id);
        var f = document.createElement('iframe');
        f.src = '//api.flattr.com/button/view/?uid=qiansen1386&button=compact&url=https:\/\/qiansen1386.github.io\/&title=东方孤思子のBlog\nParis·Qian Sen';
        f.title = 'Flattr';
        f.height = 20;
        f.width = 110;
        f.style.borderWidth = 0;
        s.parentNode.insertBefore(f, s);
      })('flattr');
    </script></p>
    

    <p><a href="https://qiansen1386.github.io/license/" class="copyright">Some Rights Reserved &copy; 2016</a><br>
      Proudly powered by <a href="https://gohugo.io">Hugo</a> <br>
      Theme: Customized <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">[转] ES6 的模块系统（附CommonJS &amp; AMD 相关）</h1>
    <span class="post-date">Mar 28, 2016 &middot; <a href="https://qiansen1386.github.io/p/2016-03-28/es6-module-system#disqus_thread">Comments</a>
    
    <br/>
    <a class="label" href="https://qiansen1386.github.io/categories/%E5%BC%80%E5%8F%91">开发</a><a class="label" href="https://qiansen1386.github.io/categories/%E4%B8%AD%E6%96%87">中文</a>
    </span>
    

<blockquote>
<p><a href="https://segmentfault.com/a/1190000003410285" target="_blank">原文</a> by <a href="https://segmentfault.com/blog/juryxiong" target="_blank">Jury Xiong&rsquo;s Blog</a> 依照<a href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">知识共享署名-相同方式共享 3.0 中国大陆许可协议</a>发布</p>
</blockquote>

<p>此文为翻译，原文地址在这儿：<a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/" target="_blank">https://hacks.mozilla.org/2015/08/es6-in-depth-modules/</a></p>

<p>ES6 是 ECMAScript 第 6 版本的简称，这是新一代的 JavaScript 的标准。<a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank">ES6 in Depth</a> 是关于 ES6 的一系列新特性的介绍。</p>

<p>遥想 2007 年，笔者开始在 Mozilla 的 JavaScript 团队工作的时候，那个时候典型的 JavaScript 程序只有一行代码。</p>

<p>两年之后， Google Map 被发布。但是在那之前不久，JavaScript 的主要用途还是表单验证，当然啦，你的<code>&lt;input onchange=&gt;</code>处理器平均来说只有一行。</p>

<p>事过情迁，JavaScript 项目已经变得十分庞大，社区也发展出了一些有助于开发可扩展程序的工具。首先你需要的便是模块系统。模块系统让你得以将你的工作分散在不同的文件和目录中，让它们之前得以互相访问，并且可以非常有效地加载它们。自然而然地，JavaScript 发展出了模块系统，事实上是多个模块系统（AMD，CommonJS，CMD，译者注）。不仅如此，社区还提供了包管理工具（NPM，译者注），让你可以安装和拷贝高度依赖其他模块的软件。也许你会觉得，带有模块特性的 ES6，来得有些晚了。</p>

<h2 id="模块基础">模块基础</h2>

<p>一个 ES6 的模块是一个包含了 JS 代码的文件。ES6 里没有所谓的 <code>module</code> 关键字。一个模块看起来就和一个普通的脚本文件一样，除了以下两个区别：</p>

<p>ES6 的模块自动开启严格模式，即使你没有写 <code>'use strict'</code>。
你可以在模块中使用 <code>import</code> 和 <code>export</code>。
让我们先来看看 <code>export</code>。在模块中声明的任何东西都是默认私有的，如果你想对其他模块 Public，你必须 <code>export</code> 那部分代码。我们有几种实现方法，最简单的方式是添加一个 <code>export</code> 关键字。</p>

<pre><code class="language-Node">// kittydar.js - Find the locations of all the cats in an image.
// (Heather Arthur wrote this library for real)
// (but she didn't use modules, because it was 2013)

export function detectCats(canvas, options) {
  var kittydar = new Kittydar(options);
  return kittydar.detectCats(canvas);
}

export class Kittydar {
  ... several methods doing image processing ...
}

// This helper function isn't exported.
function resizeCanvas() {
  ...
}
...
</code></pre>

<p>你可以在 <code>function</code>、<code>class</code>、<code>var</code>、<code>let</code> 或 <code>const</code> 前添加 <code>export</code>。</p>

<p>如果你想写一个模块，有这些就够了！再也不用把代码放在 IIFE 或者一个回调函数里了。既然你的代码是一个模块，而非脚本文件，那么你生命的一切都会被封装进模块的作用域，不再会有跨模块或跨文件的全局变量。你导出的声明部分则会成为这个模块的 Public API。</p>

<p>除此之外，模块里的代码和普通代码没啥大区别。它可以访问一些基本的全局变量，比如 <code>Object</code> 和 <code>Array</code>。如果你的模块跑在浏览器里，它将可以访问 <code>document</code> 和 <code>XMLHttpRequest</code>。</p>

<p>在另外一个文件中，我们可以导入这个模块并且使用 <code>detectCats()</code> 函数：</p>

<pre><code class="language-Node">// demo.js - Kittydar demo program

import {detectCats} from &quot;kittydar.js&quot;;

function go() {
    var canvas = document.getElementById(&quot;catpix&quot;);
    var cats = detectCats(canvas);
    drawRectangles(canvas, cats);
}
</code></pre>

<p>要导入多个模块中的接口，你可以这样写：</p>

<pre><code class="language-Node">import {detectCats, Kittydar} from &quot;kittydar.js&quot;;
</code></pre>

<p>当你运行一个包含 <code>import</code> 声明的模块，被引入的模块会先被导入并加载，然后根据依赖关系，每一个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，以此避免依赖循环。</p>

<p>这便是模块的基础部分，挺简单的。</p>

<h2 id="导出表">导出表</h2>

<p>如果你觉得在每个要导出的部分前都写上 export 很麻烦，你可以只写一行你想要导出的变量列表，再用花括号包起来。</p>

<pre><code class="language-Node">export {detectCats, Kittydar};

// no `export` keyword required here
function detectCats(canvas, options) { ... }
class Kittydar { ... }
</code></pre>

<p>导出表不一定要出现在文件的第一行，它可以出现在模块顶级作用域中的任何一行。你可以写多个导出表，也可以在列表中再写上其他 <code>export</code> 声明，只要没有变量名被重复导出即可。</p>

<h2 id="重名命导出和导入">重名命导出和导入</h2>

<p>如果导入的变量名恰好和你模块中的变量名冲突了，ES6 允许你给你导入的东西重命名：</p>

<pre><code class="language-Node">// suburbia.js

// Both these modules export something named `flip`.
// To import them both, we must rename at least one.
import {flip as flipOmelet} from &quot;eggs.js&quot;;
import {flip as flipHouse} from &quot;real-estate.js&quot;;
...
</code></pre>

<p>类似地，你在导出变量的时候也能重命名。这个特性在你想将同一个变量名导出两次的场景下十分方便，举个栗子：</p>

<pre><code class="language-Node">// unlicensed_nuclear_accelerator.js - media streaming without drm
// (not a real library, but maybe it should be)

function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
</code></pre>

<h2 id="默认导出">默认导出</h2>

<p>新一代的标准的设计理念是兼容现有的 <code>CommonJS</code> 和 <code>AMD</code> 模块。所以如果你有一个 Node 项目，并且刚刚执行完 <code>npm install lodash</code>，你的 ES6 代码可以独立引入 Lodash 中的函数：</p>

<pre><code class="language-Node">import {each, map} from &quot;lodash&quot;;

each([3, 2, 1], x =&gt; console.log(x));
</code></pre>

<p>然而如果你已经习惯了 <code>_.each</code> 或者看不见 <code>_</code> 的话就浑身难受，当然这样使用 Lodash 也是不错的方式。</p>

<p>这种情况下，你可以稍微改变一下你的 import 写法，不写花括号：</p>

<pre><code class="language-Node">import _ from &quot;lodash&quot;;
</code></pre>

<p>这个简写等价于 <code>import {default as _} from &quot;lodash&quot;;</code>。所有 <code>CommonJS</code> 和 <code>AMD</code> 模块在被 ES6 代码使用的时候都已经有了默认的导出，这个导出和你在 <code>CommonJS</code> 中 <code>require()</code> 得到的东西是一样的，那就是 <code>exports</code> 对象。</p>

<p>ES6 的模块系统被设计成让你可以一次性引入多个变量。但对于已经存在的 CommonJS 模块来说，你能得到的只有默认导出。举个栗子，在撰写此文之时，据笔者所知，著名的 <a href="https://github.com/Marak/colors.js" target="_blank">colors</a> 模块并未特意支持 ES6。这是一个由多个 CommonJS 模块组成的模块，正如 npm 上的那些包。然而你依然可以直接将其引入到你的 ES6 代码中。</p>

<pre><code class="language-Node">// ES6 equivalent of `var colors = require(&quot;colors/safe&quot;);`
import colors from &quot;colors/safe&quot;;
</code></pre>

<p>如果你想写自己的默认导出，那也很简单。这里面并没有什么高科技，它和普通的导出没什么两样，除了它的导出名是 <code>default</code>。你可以使用我们之前已经介绍过的语法：</p>

<pre><code class="language-Node">let myObject = {
  field1: value1,
  field2: value2
};
export {myObject as default};
</code></pre>

<p>这样更好：</p>

<pre><code class="language-Node">export default {
  field1: value1,
  field2: value2
};
</code></pre>

<p><code>export default</code> 关键字后可以跟随任何值：函数，对象，对象字面量，任何你能说得出的东西。</p>

<h2 id="模块对象">模块对象</h2>

<p>抱歉，这篇文章的内容有点多，但 JavaScript 已经算好的了：因为一些原因，所有语言的模块系统都有一大堆没什么卵用的特性。所幸的是，咱们只有一个话题要讨论了，呃，好吧，两个。</p>

<pre><code class="language-Node">import * as cows from &quot;cows&quot;;
</code></pre>

<p>当你 <code>import *</code>，被引入进来的是一个 <code>module namespace object</code>。它的属性是那个模块的导出，所以如果 “cows” 模块导出了一个名为 <code>moo()</code> 的函数，当你像这样引入了 “cows” 之后，你可以这样写 <code>cows.moo()</code>。</p>

<h2 id="聚合模块">聚合模块</h2>

<p>有时候一个包的主模块会引入许多其他模块，然后再将它们以一个统一的方式导出。为了简化这样的代码，我们有一个 import-and-export 的简写方法：</p>

<pre><code class="language-Node">// world-foods.js - good stuff from all over

// import &quot;sri-lanka&quot; and re-export some of its exports
export {Tea, Cinnamon} from &quot;sri-lanka&quot;;

// import &quot;equatorial-guinea&quot; and re-export some of its exports
export {Coffee, Cocoa} from &quot;equatorial-guinea&quot;;

// import &quot;singapore&quot; and export ALL of its exports
export * from &quot;singapore&quot;;
</code></pre>

<p>这种 <code>export-from</code> 的表达式和后面跟了一个 <code>export</code> 的 <code>import-from</code> 表达式类似。但和真正的导入不同，它并不会在你的作用域中加入二次导出的变量绑定。所以如果你打算在 <code>world-foods.js</code> 写用到了 <code>Tea</code> 的代码，就别使用这个简写形式。</p>

<p>如果 &ldquo;singapore&rdquo; 导出的某一个变量恰巧和其他的导出变量名冲突了，那么这里就会出现一个错误。所以你应该谨慎使用 <code>export *</code>。</p>

<p>Whew！我们介绍完语法了，接下来进入有趣的环节。</p>

<h2 id="import-到底干了啥"><code>import</code> 到底干了啥</h2>

<p>啥也没干，信不信由你。</p>

<p>噢，你好像看起来没那么好骗。好吧，那你相信标准几乎没有谈到 <code>import</code> 该做什么吗？你认为这是一件好事还是坏事呢？</p>

<p>ES6 将模块的加载细节<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule" target="_blank">完全交给了实现</a>，其余的执行部分则<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob" target="_blank">规定得非常详细</a>。</p>

<p>大致来说，当 JS 引擎运行一个模块的时候，它的行为大致可归纳为以下四步：</p>

<ol>
<li>解析：引擎实现会阅读模块的源码，并且检查是否有语法错误。</li>
<li>加载：引擎实现会（递归地）加载所有被引入的模块。这部分咱还没标准化。</li>
<li>链接：引擎实现会为每个新加载的模块创建一个作用域，并且将模块中的声明绑定填入</li>
</ol>

<p>其中，包括从其他模块中引入的。
当你尝试 <code>import {cake} from &quot;paleo&quot;</code> 但是 “paleo” 模块并没有导出叫 <code>cake</code> 的东西时候，你也会在此时得到错误。这很糟糕，因为你离执行 JS，品尝 <code>cake</code> 只差一步了！</p>

<ol>
<li>执行：终于，JS 引擎开始执行刚加载进来的模块中的代码。到这个时候，<code>import</code> 的处理过程已经完成，因此当 JS 引擎执行到一行 import 声明的时候，它啥也不会干。
看到了不？我说了 <code>import</code> “啥也没干”，没骗你吧？有关编程语言的严肃话题，哥从不说谎。</li>
</ol>

<p>不过，现在咱们可以介绍这个体系中有趣的部分了，这是一个非常酷的 trick。正因为这个体系并没有指定加载的细节，也因为你只需要看一眼源码中的 <code>import</code> 声明就可以在运行前搞清楚模块的依赖，某些 ES6 的实现甚至可以通过预处理就完成所有的工作，然后将模块全部打包成一个文件，最后通过网络分发。像 <a href="http://www.2ality.com/2015/04/webpack-es6.html" target="_blank">webpack</a> 这样的工具就是做这个事情的。</p>

<p>这非常的了不起，因为通过网络加载资源是非常耗时的。假设你请求一个资源，接着发现里面有 <code>import</code> 声明，然后你又得请求更多的资源，这又会耗费更多的时间。一个 naive 的 loader 实现可能会发起许多次网络请求。但有了 webpack，你不仅可以在今天就开始使用 ES6，还可以得到一切模块化的好处并且不向运行时性能妥协。</p>

<p>原先我们计划过一个详细定义的 ES6 模块加载规范，而且我们做出来了。它没有成为最终标准的原因之一是它无法与打包这一特性调和。模块系统需要被标准化，打包也不应该被放弃，因为它太好了。</p>

<h2 id="动态-vs-静态-或者说-规矩和如何打破规矩">动态 VS 静态，或者说：规矩和如何打破规矩</h2>

<p>作为一门动态编程语言，JavaScript 令人惊讶地拥有一个静态的模块系统。</p>

<ul>
<li><code>import</code> 和 <code>export</code> 只能写在顶级作用域中。你无法在条件语句中使用引入和导出，你也不能在你写的函数作用域中使用 <code>import</code>。</li>
<li>所有的导出必须显示地指定一个变量名，你也无法通过一个循环动态地引入一堆变量。</li>
<li>模块对象被封装起来了，我们无法通过 polyfill 去 hack 一个新 feature。</li>
<li>在模块代码运行之前，所有的模块都必须经历加载，解析，链接的过程。没有可以延迟加载，惰性 <code>import</code> 的语法。</li>
<li>对于 <code>import</code> 错误，你无法在运行时进行 <code>recovery</code>。一个应用可能包含了几百个模块，其中的任何一个加载失败或链接失败，这个应用就不会运行。你无法在 <code>try/catch</code> 语句中 <code>import</code>。（不过正因为 ES6 的模块系统是如此地静态，webpack 可以在预处理时就为你检测出这些错误）。</li>
<li>你没办法 hook 一个模块，然后在它被加载之前运行你的一些代码。这意味着模块无法控制它的依赖是如何被加载的。</li>
</ul>

<p>只要你的需求都是静态的话，这个模块系统还是很 nice 的。但你还是想 hack 一下，是吗？</p>

<p>这就是为啥你使用的模块加载系统可能会提供 API。举个栗子，<a href="http://webpack.github.io/docs/code-splitting.html" target="_blank">webpack 有一个 API</a>，允许你 “code splitting”，按照你的需求去惰性加载模块。这个 API 也能帮你打破上面列出的所有规矩。</p>

<p>ES6 的模块是非常静态的，这很好——许多强大的编译器工具因此收益。而且，静态的语法已经被设计成可以和动态的，可编程的 loader API 协同工作。</p>

<h2 id="我何时能开始使用-es6-模块">我何时能开始使用 ES6 模块？</h2>

<p>如果你今天就要开始使用，你需要诸如 <a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank">Traceur</a> 和 <a href="http://babeljs.io/" target="_blank">Babel</a> 这样的预处理工具。这个系列专题之前也有文章介绍了<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-babel-and-broccoli/" target="_blank">如何使用 Babel 和 Broccoli</a> 去生成可用于 Web 的 ES6 代码。那篇文章的栗子也被<a href="https://github.com/givanse/broccoli-babel-examples/tree/master/es6-modules" target="_blank">开源在了 GitHub 上</a>。笔者的<a href="http://www.2ality.com/2015/04/webpack-es6.html" target="_blank">这篇文章</a>也介绍了如何使用 Babel 和 webpack。</p>

<p>ES6 模块系统的主要设计者是 Dave Herman 和 Sam Tobin-Hochstadt，此二人不顾包括笔者在内的数位委员的反对，始终坚持如今你见到的 ES6 模块系统的静态部分，争论长达数年。Jon Coppeard 正在火狐浏览器上实现 ES6 的模块。之后包括 JavaScript Loader 规范在内的工作已经在进行中。HTML 中类似 <code>&lt;script type=module&gt;</code> 这样的东西之后也会和大家见面。</p>

<p>这便是 ES6 了。</p>

<p>欢迎大家对 ES6 进行吐槽，请期待下周 <a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank">ES6 in Depth</a> 系列的总结文章。
<small style="float:right">2015年08月21日发布</small></p>

<blockquote>
<p>除此文之外，还推荐其他参考资料，因版权不明，我尽量多导流少转载：</p>

<ul>
<li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank">CommonJS规范 - 阮一峰</a></li>
<li><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank">exports 和 module.exports 的区别</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank">浏览器加载 CommonJS 模块的原理与实现 - 阮一峰</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">Javascript模块化编程（一）：模块的写法 - 阮一峰</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank">Javascript模块化编程（二）：AMD规范 - 阮一峰</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank">Javascript模块化编程（三）：require.js的用法 - 阮一峰</a></li>
<li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank">&ldquo;AMD&rdquo;文档（中文版）存档</a>)</li>
</ul>
</blockquote>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "qiansen1386";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "qiansen1386";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


<script src="https://qiansen1386.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript">
var sc_project=9662348; 
var sc_invisible=0; 
var sc_security="e5e8f246"; 
var scJsHost = (("https:" == document.location.protocol) ?"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='"+scJsHost+"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="shopify traffic
stats" href="http://statcounter.com/shopify/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/9662348/0/e5e8f246/0/" alt="shopify
traffic stats"></a></div></noscript>

</body>
</html>

